// =========================
// Helpers
// =========================

function decodeEntities(str) {
  if (!str) return '';
  return str
    .replace(/&nbsp;/g,' ')
    .replace(/&amp;/g,'&')
    .replace(/&quot;/g,'"')
    .replace(/&#39;|&apos;/g,"'")
    .replace(/&lt;/g,'<')
    .replace(/&gt;/g,'>')
    .replace(/&#(\d+);/g, (_, n) => String.fromCharCode(Number(n)))
    .replace(/&#x([0-9a-fA-F]+);/g, (_, n) => String.fromCharCode(parseInt(n, 16)));
}

function cleanWhitespace(s) {
  return (s || '').replace(/\r?\n/g,' ').replace(/\s+/g,' ').trim();
}

function extractMoney(text) {
  const match = text.match(/(IDR|USD|\$)\s?(-?[\d,]+\.\d{2})/i);
  if (!match) return null;

  const currency = match[1] === '$' ? 'USD' : match[1].toUpperCase();
  const numeric = parseFloat(match[2].replace(/,/g,''));
  const formatted = match[2].split('.')[0] + ' ' + currency;

  return { currency, numeric, formatted };
}

// =========================
// Main Parser
// =========================

return $input.all().map(item => {

  const j = item.json || {};
  const html = j.textAsHtml || j.body || '';

  const flatText = cleanWhitespace(
    decodeEntities(html.replace(/<br\s*\/?>/gi,' ').replace(/<[^>]*>/g,' '))
  );

  const channel = "agoda";

  // =========================
  // Booking ID
  // =========================
  const bookingMatch = flatText.match(/Booking\s*ID\s*([0-9]+)/i);
  const bookingId = bookingMatch ? bookingMatch[1] : '';

  // =========================
  // Guest Name
  // =========================
  const firstNameMatch = html.match(/id="ltrCustomerFirstNameValue"[^>]*>([^<]+)/i);
  const lastNameMatch  = html.match(/id="ltrCustomerLastNameValue"[^>]*>([^<]+)/i);
  
  const customerFirstName = firstNameMatch ? cleanWhitespace(decodeEntities(firstNameMatch[1])) : '';
  const customerLastName  = lastNameMatch  ? cleanWhitespace(decodeEntities(lastNameMatch[1]))  : '';

  // =========================
  // Dates
  // =========================
  const checkInMatch  = flatText.match(/Check-?in\s+([A-Za-z]+\s+\d{1,2},\s*\d{4})/i);
  const checkOutMatch = flatText.match(/Check-?out\s+([A-Za-z]+\s+\d{1,2},\s*\d{4})/i);

  const checkIn  = checkInMatch  ? checkInMatch[1]  : '';
  const checkOut = checkOutMatch ? checkOutMatch[1] : '';

  // =========================
  // Nights Calculation
  // =========================
  
  let noOfNights = '';
  
  if (checkIn && checkOut) {
    const inDate = new Date(checkIn);
    const outDate = new Date(checkOut);
    const diff = (outDate - inDate) / (1000 * 60 * 60 * 24);
    noOfNights = diff > 0 ? diff.toString() : '';
  }
  
  // =========================
  // Room Type + Units
  // =========================
  
  let roomType = '';
  let noOfRooms = '';
  let unitCode = '';
  let rawRoomType = '';
  
  // Extract number of rooms
  const roomsMatch = html.match(/lblNumberRoomsData_lblMain[^>]*>(\d+)</i);
  if (roomsMatch) {
    noOfRooms = roomsMatch[1];
  }
  
  // Extract room type safely
  const roomTypeMatch = html.match(/lblRoomTypeData_lblMain[^>]*>([^<]+)</i);
  
  if (roomTypeMatch) {
    rawRoomType = cleanWhitespace(decodeEntities(roomTypeMatch[1]));
  
    // Get ALL parentheses groups
    const allParens = rawRoomType.match(/\(([^)]+)\)/g);
  
    if (allParens && allParens.length > 0) {
      // Take LAST parentheses group (real unit code)
      const lastGroup = allParens[allParens.length - 1];
      unitCode = lastGroup.replace(/[()]/g, '').toUpperCase().trim();
    }
  }
  
  // =========================
  // Property Mapping
  // =========================
  
  let propertyId = '';
  
  if (/Pom Pom/i.test(flatText)) propertyId = "POMS";
  if (/Middle House/i.test(flatText)) propertyId = "MH";
  if (/Ulu Hills/i.test(flatText)) propertyId = "ULU";
  
  // =========================
  // Unit Mapping
  // =========================

  // Poms Units
  if (propertyId === "POMS" && unitCode) {
    if (/AHIP/i.test(unitCode)) roomType = "Living Room Suite";
    else if (/BG/i.test(unitCode)) roomType = "Patio Suite with Kitchen";
    else if (/CDEF/i.test(unitCode)) roomType = "Ground Floor Standard Suite";
    else if (/JO/i.test(unitCode)) roomType = "Balcony Suite";
    else if (/KLMN/i.test(unitCode)) roomType = "Second Floor Standard Suite";
    else roomType = rawRoomType;
  }

  // MH Units
  else if (propertyId === "MH" && unitCode) {
  
    if (["MH1", "MH2"].includes(unitCode)) {
      roomType = "Balcony Suite";
    }
    else if (["MH3", "MH4"].includes(unitCode)) {
      roomType = "Garden Suite";
    }
    else if (["MH5", "MH6"].includes(unitCode)) {
      roomType = "Pool Room";
    }
    else if (unitCode === "MH-WHOLE") {
      roomType = "Whole Villa";
    }
    else {
      roomType = rawRoomType;
    }
  
  }

  // Ulu Units
  else if (propertyId === "ULU" && unitCode) {
  
    if (["V1", "V2", "V4", "V5"].includes(unitCode)) {
      roomType = "1 Bedroom Villa";
    }
    else if (unitCode === "V3") {
      roomType = "2 Bedroom Villa";
    }
    else if (["V6", "V7"].includes(unitCode)) {
      roomType = "3 Bedroom Villa";
    }
    else {
      roomType = rawRoomType;
    }
  
  }
  
  else {
    roomType = rawRoomType;
  }

  // =========================
  // Assigned Unit (direct from unitCode)
  // =========================
  
  let assignedUnit = unitCode || '';

  // =========================
  // Pricing
  // =========================

  let currency = '';
  let nightlyRate = '';
  let nightlyRateValue = 0;
  let totalPayment = '';
  let totalPaymentValue = 0;
  let otaFees = '';
  let otaFeesValue = 0;
  let taxes = '';
  let payout = '';
  let payoutValue = 0;
  
  // ---- Reference Sell Rate (this is what guest paid)
  const sellRateMatch = flatText.match(/Reference sell rate.*?(IDR|USD|\$)\s?([\d,]+\.\d{2})/i);
  
  if (sellRateMatch) {
    const money = extractMoney(sellRateMatch[0]);
    if (money) {
      currency = money.currency;
      totalPaymentValue = money.numeric;
      totalPayment = money.formatted;
    }
  }
  
  // ---- Commission / Compensation (Agoda OTA fee)
  
  // 1️⃣ Try Commission row (some templates use this)
  let commissionMatch = html.match(
    /Commission<\/span>[\s\S]*?(IDR|USD|\$)<\/span>\s*<span[^>]*>\s*-?([\d,]+\.\d{2})/i
  );
  
  // 2️⃣ If not found, try Compensation row
  if (!commissionMatch) {
    commissionMatch = html.match(
      /compensation_lbl[\s\S]*?(IDR|USD|\$)<\/span>\s*<span[^>]*>\s*-?([\d,]+\.\d{2})/i
    );
  }
  
  if (commissionMatch) {
    const currencyCode = commissionMatch[1] === '$'
      ? 'USD'
      : commissionMatch[1].toUpperCase();
  
    const numeric = Math.abs(
      parseFloat(commissionMatch[2].replace(/,/g, ''))
    );
  
    otaFeesValue = numeric;
    otaFees = numeric.toLocaleString('en-US') + ' ' + currencyCode;
  }
  
  // ---- Tax on Commission
  const taxMatch = flatText.match(/Tax on Commission.*?(IDR|USD|\$)\s?-?([\d,]+\.\d{2})/i);
  if (taxMatch) {
    const money = extractMoney(taxMatch[0]);
    if (money) {
      taxes = Math.abs(money.numeric).toLocaleString('en-US') + ' ' + money.currency;
    }
  }

  // ---- Net Rate (Actual Payout)
  const netRateMatch = flatText.match(/Net rate.*?(IDR|USD|\$)\s?([\d,]+\.\d{2})/i);
  
  if (netRateMatch) {
    const money = extractMoney(netRateMatch[0]);
    if (money) {
      payoutValue = money.numeric;
      payout = money.formatted;
    }
  }

  // ---- Calculate nightly rate (per room per night)
  if (totalPaymentValue && noOfNights && noOfRooms) {
  
    const nights = parseInt(noOfNights);
    const rooms  = parseInt(noOfRooms);
  
    nightlyRateValue = totalPaymentValue / (nights * rooms);
  
    nightlyRate = nightlyRateValue.toLocaleString('en-US') + ' ' + currency;
  
  }

  // =========================
  // Occupied Nights (for occupancy tracking)
  // =========================
  
  let occupiedNights = 0;
  
  if (noOfNights && noOfRooms) {
    const nights = parseInt(noOfNights);
    const rooms  = parseInt(noOfRooms);
    occupiedNights = nights * rooms;
  }

  // =========================
  // Final Output
  // =========================

  return {
    bookingId,
    propertyId,
    customerFirstName,
    customerLastName,
    checkIn,
    checkOut,
    noOfNights,
    occupiedNights,
    roomType,
    assignedUnit,
    noOfRooms,
    channel,
    currency,
    nightlyRate,
    nightlyRateValue,
    totalPayment,
    totalPaymentValue,
    taxes,
    otaFees,
    otaFeesValue,
    payout,
    payoutValue
  };

});
